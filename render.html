<html><!--=======================================================================-->

<head>
    <meta http-equiv="Content-Type" content="text/html">
    <meta charset="UTF-8">
    <title>Your Puzzle Here!</title>
    <link rel="stylesheet" href="./css/main.css">
</head>

<!--=======================================================================-->

<body onload="initialize()" data-new-gr-c-s-check-loaded="14.1173.0" data-gr-ext-installed="">
    <!-- <center>
        <input id='testnode'
        type='text'
        value='hello'
        size='30'
        style='color:black'
        display ='none'/>
    </center> -->
    <center>
        <h1 id="mode_heading">Choose Your Game Mode!</h1>
        <div>
            <button class="btn btn-primary" onclick="modbutton(this)" id="easy_mode" widget="button">Easy</button>
        </div> 
        <div>
            <button class="btn btn-primary" onclick="modbutton(this)" id="hard_mode" widget="button">Hard</button>
        </div>

        <!--=======================================================================-->

        <h1 id="heading" style="display: none;">Your Puzzle Here!</h1>
        <table id="puzzle_grid" >
            <thead>
                <tr>
                    <th></th>
                    <th>Column 1</th>
                    <th>Column 2</th>
                    <th>Column 3</th>
                    <th>Column 4</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>Row 1</th>
                    <td><select class="cell-select" id="cell(1,1)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(1,2)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(1,3)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(1,4)" onchange="modselector(this)"></select></td>
                </tr>
                <tr>
                    <th>Row 2</th>
                    <td><select class="cell-select" id="cell(2,1)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(2,2)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(2,3)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(2,4)" onchange="modselector(this)"></select></td>
                </tr>
                <tr>
                    <th>Row 3</th>
                    <td><select class="cell-select" id="cell(3,1)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(3,2)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(3,3)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(3,4)" onchange="modselector(this)"></select></td>
                <tr>
                    <th>Row 4</th>
                    <td><select class="cell-select" id="cell(4,1)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(4,2)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(4,3)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-select" id="cell(4,4)" onchange="modselector(this)"></select></td>
                </tr>
            </tbody>
        </table>
    </center>
    <span id="clue_section" display="none">
        <h1 class="clues_heading" id="clues_heading">Clues~~</h1>
        <div class="clue-container">
            <span id="clue(1)" class="clue"></span>
            <span id="clue(2)" class="clue"></span>
            <span id="clue(3)" class="clue"></span>
            <span id="clue(4)" class="clue"></span>
            <span id="clue(5)" class="clue"></span>
            <span id="clue(6)" class="clue"></span>
            <span id="clue(7)" class="clue"></span>
            <span id="clue(8)" class="clue"></span>
            <span id="clue(9)" class="clue"></span>
            <span id="clue(10)" class="clue"></span>
            <span id="clue(11)" class="clue"></span>
            <span id="clue(12)" class="clue"></span>
        </div>
    </span>
    <div>
        <button class="btn btn-primary" onclick="modbutton(this)" id="rule_button" widget="button">Show Me the Rules!</button>
    </div> 
    <div>
        <button class="btn btn-primary" onclick="modbuttonstart(this); modbutton(this)" id="start_button" widget="button" style="display: none;">Start the GAME!</button>
    </div>
    <div>
        <button class="btn btn-primary" onclick="modbutton(this)" id="init_hint" widget="button" style="display: none;"></button>
    </div>
    <div>
        <button class="btn btn-primary" onclick="modbutton(this)" id="add_clue" widget="button" style="display: none;">Add Clue</button>
    </div>
    <div>
        <button class="btn btn-primary" onclick="modbutton(this)" id="verify_button" widget="button" style="display: none;">Verify Your
            Solution!</button>
    </div>
    <div>
        <button class="btn btn-primary" onclick="modbutton(this)" id="solution_button_easy" widget="button" style="display: none;">Check One
            Potential Solution!</button>
    </div>
    <div>
        <button class="btn btn-primary" onclick="modbutton(this)" id="solution_button_hard" widget="button" style="display: none;">Check the Solution!</button>
    </div>
    


    <div class="hidden-message-win" id="win_message">
        Congratulations! You WIN the game!
    </div>

    <div class="hidden-message-lose" id="lose_message">
        Sorry! You LOSE the game!
    </div>

    <center>
        <table id="puzzle_grid_ans" class="ans_table">
            <thead>
                <tr>
                    <th></th>
                    <th>Column 1</th>
                    <th>Column 2</th>
                    <th>Column 3</th>
                    <th>Column 4</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>Row 1</th>
                    <td><select class="cell-ans" id="ans_cell(1,1)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(1,2)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(1,3)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(1,4)" onchange="modselector(this)"></select></td>
                </tr>
                <tr>
                    <th>Row 2</th>
                    <td><select class="cell-ans" id="ans_cell(2,1)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(2,2)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(2,3)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(2,4)" onchange="modselector(this)"></select></td>
                </tr>
                <tr>
                    <th>Row 3</th>
                    <td><select class="cell-ans" id="ans_cell(3,1)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(3,2)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(3,3)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(3,4)" onchange="modselector(this)"></select></td>
                <tr>
                    <th>Row 4</th>
                    <td><select class="cell-ans" id="ans_cell(4,1)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(4,2)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(4,3)" onchange="modselector(this)"></select></td>
                    <td><select class="cell-ans" id="ans_cell(4,4)" onchange="modselector(this)"></select></td>
                </tr>
            </tbody>
        </table>
    </center>


    <center>
        <dataset id="lambda" type="text/hrf" style="display:none">
            init_puzzle

            rule_hidden

            row(1)
            row(2)
            row(3)
            row(4)

            col(1)
            col(2)
            col(3)
            col(4)

            shape(circle)
            shape(square)
            shape(heart)
            shape(book)

            color(blue)
            color(red)
            color(green)
            color(yellow)

            translate(red_circle, "🔴")
            translate(red_heart, "❤️")
            translate(red_square, "🟥")
            translate(red_book, "📕")

            translate(blue_circle, "🔵")
            translate(blue_heart, "💙")
            translate(blue_square, "🟦")
            translate(blue_book, "📘")

            translate(yellow_circle, "🟡")
            translate(yellow_heart, "💛")
            translate(yellow_square, "🟨")
            translate(yellow_book, "📒")

            translate(green_circle, "🟢")
            translate(green_heart, "💚")
            translate(green_square, "🟩")
            translate(green_book, "📗")

            shape_to_emoji(circle, "⚫")
            shape_to_emoji(heart, "🖤")
            shape_to_emoji(square, "⬛")
            shape_to_emoji(book, "📓")

            color_translate(green, "green 🟩")
            color_translate(red, "red 🟥")
            color_translate(yellow, "yellow 🟨")
            color_translate(blue, "blue 🟦")
            

            <!-- Map emoji value to shape and color -->
            <!-- emoji(V, S, C): V is value, S is shape, C is color -->
            emoji(blue_circle, circle, blue)
            emoji(red_circle, circle, red)
            emoji(green_circle, circle, green)
            emoji(yellow_circle, circle, yellow)
            emoji(blue_square, square, blue)
            emoji(red_square, square, red)
            emoji(green_square, square, green)
            emoji(yellow_square, square, yellow)
            emoji(blue_heart, heart, blue)
            emoji(red_heart, heart, red)
            emoji(green_heart, heart, green)
            emoji(yellow_heart, heart, yellow)
            emoji(blue_book, book, blue)
            emoji(red_book, book, red)
            emoji(green_book, book, green)
            emoji(yellow_book, book, yellow)

        </dataset>

        <!-- ======================================================================= -->

        <ruleset id="library" type="text/hrf" style="display:none">
            <!-- select an element for the grid -->
            select(cell(R, C), V):: value(cell(R, C), V)
            select(cell(R, C), V):: value(cell(R, C), V1) ==> ~value(cell(R, C), V1)

            <!-- mode logic -->
            style(mode_heading, display, none) :- mode_chosen
            style(easy_mode, display, none) :- mode_chosen
            style(hard_mode, display, none) :- mode_chosen

            click(easy_mode) :: mode_chosen & mode_easy
            click(hard_mode) :: mode_chosen & mode_hard

            style(heading, display, inline) :- mode_chosen & ~init_puzzle
            style(start_button, display, inline) :- mode_chosen
            <!-- randomly generate a valid grid -->

            valid_row_color([C1, C2, C3, C4]) :-
                color(C1) & color(C2) & color(C3) & color(C4) & mutex(C1, C2, C3, C4)
            
            random_row_color(C) :- evaluate(choose(X, valid_row_color(X)), C)

            valid_grid_shape([S11, S12, S13, S14, S21, S22, S23, S24, S31, S32, S33, S34, S41, S42, S43, S44]) :-
                shape(S11) & shape(S12) & shape(S13) & shape(S14) & mutex(S11, S12, S13, S14) &
                shape(S21) & shape(S22) & shape(S23) & shape(S24) & mutex(S21, S22, S23, S24) &
                mutex(S11, S21) & mutex(S12, S22) & mutex(S13, S23) & mutex(S14, S24) &
                shape(S31) & shape(S32) & shape(S33) & shape(S34) & mutex(S31, S32, S33, S34) &
                mutex(S11, S21, S31) & mutex(S12, S22, S32) & mutex(S13, S23, S33) & mutex(S14, S24, S34) &
                shape(S41) & shape(S42) & shape(S43) & shape(S44) & mutex(S41, S42, S43, S44) &
                mutex(S11, S21, S31, S41) & mutex(S12, S22, S32, S42) & mutex(S13, S23, S33, S43) & mutex(S14, S24, S34, S44)

            random_grid_shape(S) :- evaluate(choose(X, valid_grid_shape(X)), S)

            random_grid([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) :-
                random_row_color([C1, C2, C3, C4]) & 
                random_grid_shape([S11, S12, S13, S14, S21, S22, S23, S24, S31, S32, S33, S34, S41, S42, S43, S44]) &
                emoji(X11, S11, C1) & emoji(X12, S12, C1) & emoji(X13, S13, C1) & emoji(X14, S14, C1) &
                emoji(X21, S21, C2) & emoji(X22, S22, C2) & emoji(X23, S23, C2) & emoji(X24, S24, C2) &
                emoji(X31, S31, C3) & emoji(X32, S32, C3) & emoji(X33, S33, C3) & emoji(X34, S34, C3) &
                emoji(X41, S41, C4) & emoji(X42, S42, C4) & emoji(X43, S43, C4) & emoji(X44, S44, C4)
                        
            <!-- init Game -->
            click(start_button) :: init_puzzle & random_grid([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) 
                ==> ~init_puzzle & 
                    fill_in([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) & init_hint

            click(init_hint) :: ~init_puzzle & init_hint & clue_set(ClueSet)
                    ==> display_clue(ClueSet) & ~init_hint
    
        
            <!-- fill in the potential answer -->
            fill_in([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) ::
               value(ans_cell(1,1), X11) & value(ans_cell(1,2), X12) & value(ans_cell(1,3), X13) & value(ans_cell(1,4), X14) &
                value(ans_cell(2,1), X21) & value(ans_cell(2,2), X22) & value(ans_cell(2,3), X23) & value(ans_cell(2,4), X24) &
                value(ans_cell(3,1), X31) & value(ans_cell(3,2), X32) & value(ans_cell(3,3), X33) & value(ans_cell(3,4), X34) &
                value(ans_cell(4,1), X41) & value(ans_cell(4,2), X42) & value(ans_cell(4,3), X43) & value(ans_cell(4,4), X44)
                  
            <!-- clue definition -->
            is_clue([Type, Clue]) :- clue_color_of_row(Clue) & evaluate(color_of_row, Type)
            is_clue([Type, Clue]) :- clue_shape_of_cell(Clue) & evaluate(shape_of_cell, Type)
            is_clue([Type, Clue]) :- clue_emoji_of_cell(Clue) & evaluate(emoji_of_cell, Type)
            is_clue([Type, Clue]) :- clue_left_of(Clue) & evaluate(left_of, Type)
            is_clue([Type, Clue]) :- clue_top_of(Clue) & evaluate(top_of, Type)

            satisfied_clue([Type, Clue]) :- evaluate(color_of_row, Type) & satisfied_clue_color_of_row(Clue)
            satisfied_clue([Type, Clue]) :- evaluate(shape_of_cell, Type) & satisfied_clue_shape_of_cell(Clue)
            satisfied_clue([Type, Clue]) :- evaluate(emoji_of_cell, Type) & satisfied_clue_emoji_of_cell(Clue)
            satisfied_clue([Type, Clue]) :- evaluate(left_of, Type) & satisfied_clue_left_of(Clue)
            satisfied_clue([Type, Clue]) :- evaluate(top_of, Type) & satisfied_clue_top_of(Clue)

            html_clue([Type, Clue], Sentence) :- evaluate(color_of_row, Type) & html_clue_color_of_row(Clue, Sentence)
            html_clue([Type, Clue], Sentence) :- evaluate(shape_of_cell, Type) & html_clue_shape_of_cell(Clue, Sentence)
            html_clue([Type, Clue], Sentence) :- evaluate(emoji_of_cell, Type) & html_clue_emoji_of_cell(Clue, Sentence)
            html_clue([Type, Clue], Sentence) :- evaluate(left_of, Type) & html_clue_left_of(Clue, Sentence)
            html_clue([Type, Clue], Sentence) :- evaluate(top_of, Type) & html_clue_top_of(Clue, Sentence)

            <!-- 1. color of a row -->
            clue_color_of_row([Color, R]) :- ~init_puzzle & color(Color) & row(R) & 
                value(ans_cell(R, 1), Emoji) & emoji(Emoji, _, Color)

                <!-- we define the clue as satisfied if the 4 emojis are of the right color-->
            satisfied_clue_color_of_row([Color, R]) :- ~init_puzzle & 
                value(cell(R, 1), Emoji1) & emoji(Emoji1, Shape1, Color) & 
                value(cell(R, 2), Emoji2) & emoji(Emoji2, Shape2, Color) & 
                value(cell(R, 3), Emoji3) & emoji(Emoji3, Shape3, Color) & 
                value(cell(R, 4), Emoji4) & emoji(Emoji4, Shape4, Color)
                <!-- & mutex(Shape1, Shape2, Shape3, Shape4) -->

            html_clue_color_of_row([Color, R], Sentence) :- 
                color_translate(Color, TC) & evaluate(stringappend("The color of row ", R, " is ", TC), Sentence) 
        
            <!-- 2. shape of a cell -->
            clue_shape_of_cell([Shape, R, C]) :- ~init_puzzle & shape(Shape) & row(R) & col(C) & 
                value(ans_cell(R, C), Emoji) & emoji(Emoji, Shape, _)

            satisfied_clue_shape_of_cell([Shape, R, C]) :- ~init_puzzle & 
                value(cell(R, C), Emoji) & emoji(Emoji, Shape, _)

            html_clue_shape_of_cell([Shape, R, C], Sentence) :- 
                shape_to_emoji(Shape, TS) & evaluate(stringjoin(["The shape at row", R, "column", C, "is", TS]), Sentence)

            <!-- 3. emoji of a cell -->
            clue_emoji_of_cell([Emoji, R, C]) :- ~init_puzzle & emoji(Emoji, _, _) & row(R) & col(C) & 
                value(ans_cell(R, C), Emoji)

            satisfied_clue_emoji_of_cell([Emoji, R, C]) :- ~init_puzzle & value(cell(R, C), Emoji)

            html_clue_emoji_of_cell([Emoji, R, C], Sentence) :- 
                translate(Emoji, TEmoji) & evaluate(stringjoin([TEmoji, "is at row", R, "column", C]), Sentence)

            <!-- 4. directly to the left ( Emoji1 left, Emoji2 right ) -->
            clue_left_of([Emoji1, Emoji2]) :- ~init_puzzle & row(R) & col(C1) & col(C2) &
                evaluate(minus(C2, 1), C1) & value(ans_cell(R, C1), Emoji1) & value(ans_cell(R, C2), Emoji2)
            
                <!-- we define the clue as satisfied only if there are no repeated Emoji1 & Emoji2 -->
            satisfied_clue_left_of([Emoji1, Emoji2]) :- ~init_puzzle &
                value(cell(R, C1), Emoji1) & value(cell(R, C2), Emoji2) & evaluate(minus(C2, 1), C1) &
                ~(value(cell(Ra, Ca), Emoji1) & (~evaluate(Ra, R) | ~evaluate(Ca, C1))) &
                ~(value(cell(Rb, Cb), Emoji2) & (~evaluate(Rb, R) | ~evaluate(Cb, C2)))

            html_clue_left_of([Emoji1, Emoji2], Sentence) :- 
                translate(Emoji1, TLeft) & translate(Emoji2, TRight) & evaluate(stringjoin([TLeft, "is to the left of", TRight]), Sentence) 

            <!-- 5. directly on top of ( Emoji1 top, Emoji2 below ) -->
            clue_top_of([Emoji1, Emoji2]) :- ~init_puzzle & row(R1) & row(R2) & col(C) &
                evaluate(minus(R2, 1), R1) & value(ans_cell(R1, C), Emoji1) & value(ans_cell(R2, C), Emoji2)

                <!-- we define the clue as satisfied only if there are no repeated Emoji1 & Emoji2 -->
            satisfied_clue_top_of([Emoji1, Emoji2]) :- ~init_puzzle &
                value(cell(R1, C), Emoji1) & value(cell(R2, C), Emoji2) & evaluate(minus(R2, 1), R1) &
                ~(value(cell(Ra, C), Emoji1) & (~evaluate(Ra, R1) | ~evaluate(C, C))) &
                ~(value(cell(Rb, C), Emoji2) & (~evaluate(Rb, R2) | ~evaluate(C, C)))

            html_clue_top_of([Emoji1, Emoji2], Sentence) :-
                translate(Emoji1, TTop) & translate(Emoji2, TBottom) & evaluate(stringjoin([TTop, "is on top of", TBottom]), Sentence) 
            <!-- TODO: other not so informative clues, e.g. on the same column -->

            <!-- generate one clue at a time and add to list -->
            random_clue(TypedClue) :- evaluate(choose(X, is_clue(X)), TypedClue)

            generate_clues(0, [])
            generate_clues(N, TypedClue!Rest) :- 
                leq(1, N) &
                evaluate(minus(N, 1), N1)&
                generate_clues(N1, Rest) &
                random_clue(TypedClue)
            
            <!-- remove duplicate clues -->
            remove_duplicates([], [])
            remove_duplicates(E!L, R) :-
                member(E, L) & remove_duplicates(L, R)
            remove_duplicates(E!L, E!R) :-
                ~member(E, L) & remove_duplicates(L, R) 

            <!-- truncate(L, R, List, N): store List[:N] in L, List[N:] in R -->
            truncate([], R, R, 0)
            truncate(E!L, R, E!List, N) :-
                leq(1, N) & evaluate(minus(N, 1), N1) & truncate(L, R, List, N1)

            <!-- get clue set (generate 25 clues and remove duplicates) --> 
            clue_set(ClueSet) :- 
                generate_clues(25, Clues) & 
                remove_duplicates(Clues, ClueSet)
                        
            <!-- all style changes -->
            style(Clue, "background-color", "rgba(116, 210, 110, 0.8)") :- satisfied_clue(H) & match_id(Clue, H)
            style(Clue, "background-color", "#f0f0f0") :- match_id(Clue, H) & ~satisfied_clue(H)

            style(puzzle_grid, display, block) :- ~init_puzzle
            style(add_clue, display, inline-block) :- ~init_puzzle & num_clue(N) & leq(N, 12)
            style(add_clue, display, none) :- init_puzzle | (num_clue(N) & leq(12, N))
            style(verify_button, display, inline-block) :- ~init_puzzle
            style(solution_button_easy, display, inline-block) :- ~init_puzzle & mode_easy
            style(solution_button_hard, display, inline-block) :- ~init_puzzle & mode_hard
            style(start_button, display, none) :- ~init_puzzle

            style(clue(ID), display, inline) :- match_id(clue(ID), _) & ~init_puzzle
            style(clues_heading, display, inline) :- ~init_puzzle
            

            <!-- display clues -->
            display_clue(ClueSet) :: 
                truncate(InitClueSet, RestClueSet, ClueSet, 7) & evaluate(InitClueSet, [H1, H2, H3, H4, H5, H6, H7]) ==> 
                num_clue(7) & restclue(RestClueSet) &
                match_id(clue(1), H1) & match_id(clue(2), H2) & match_id(clue(3), H3) & match_id(clue(4), H4) & match_id(clue(5), H5) & match_id(clue(6), H6) & match_id(clue(7), H7)

            click(add_clue) ::
                num_clue(N) & restclue(ClueSet) & evaluate(ClueSet, Clue!RestClue) & evaluate(plus(N, 1), N1) & leq(N1, 12) ==>
                ~num_clue(N) & num_clue(N1) & 
                ~restclue(ClueSet) & restclue(RestClue) & 
                match_id(clue(N1), Clue)
            
            innerhtml(clue(ID), Sentence) :- match_id(clue(ID), Clue) & html_clue(Clue, Sentence)

            <!-- rule button -->
            click(rule_button) :: rule_hidden  ==> ~rule_hidden
            click(close_button) :: ~rule_hidden ==> rule_hidden
            style(rulesModal, display, block) :- ~rule_hidden
            style(rulesModal, display, none) :- rule_hidden
    
            <!-- verify solution -->
            style(win_message, display, block) :- verify_button_clicked_win
            style(win_message, display, none) :- verify_button_clicked_lose
            style(lose_message, display, block) :- verify_button_clicked_lose
            style(lose_message, display, none) :- verify_button_clicked_win

            click(verify_button) :: mode_chosen & ~init_puzzle & check() ==> verify_button_clicked_win & ~verify_button_clicked_lose
            click(verify_button) :: mode_chosen & ~init_puzzle & ~check() ==> verify_button_clicked_lose & ~verify_button_clicked_win
            
            <!-- check if the user answer is correct in easy mode -->
            check() :- ~init_puzzle & mode_easy &
                user_answer([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) & 
                valid_grid([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) &
                valid_clueset()

            <!-- check if the user answer is correct in hard mode-->
            check() :- ~init_puzzle & mode_hard & 
                user_answer([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) & 
                exact_match([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) 

            exact_match([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) :- 
                value(ans_cell(1,1), X11) & value(ans_cell(1,2), X12) & value(ans_cell(1,3), X13) & value(ans_cell(1,4), X14) &
                value(ans_cell(2,1), X21) & value(ans_cell(2,2), X22) & value(ans_cell(2,3), X23) & value(ans_cell(2,4), X24) &
                value(ans_cell(3,1), X31) & value(ans_cell(3,2), X32) & value(ans_cell(3,3), X33) & value(ans_cell(3,4), X34) &
                value(ans_cell(4,1), X41) & value(ans_cell(4,2), X42) & value(ans_cell(4,3), X43) & value(ans_cell(4,4), X44)
                
            
            <!-- verify if clue(ID) is satisfied (empty or satisfied both counts) -->
            satisfied_clue_id(ID) :- ~match_id(clue(ID), _) | (match_id(clue(ID), H) & satisfied_clue(H))

            <!-- verify if all the clues are satisfied -->
            valid_clueset() :- iterate_valid_clue(12)
            iterate_valid_clue(0)
            iterate_valid_clue(N) :- leq(1, N) & evaluate(minus(N, 1), N1) & iterate_valid_clue(N1) & satisfied_clue_id(N)

            <!-- extract user answer -->
            user_answer([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) :-
                value(cell(1,1), X11) & value(cell(1,2), X12) & value(cell(1,3), X13) & value(cell(1,4), X14) &
                value(cell(2,1), X21) & value(cell(2,2), X22) & value(cell(2,3), X23) & value(cell(2,4), X24) &
                value(cell(3,1), X31) & value(cell(3,2), X32) & value(cell(3,3), X33) & value(cell(3,4), X34) &
                value(cell(4,1), X41) & value(cell(4,2), X42) & value(cell(4,3), X43) & value(cell(4,4), X44)
            
            <!-- verify if a grid satisfied the basic rule (don't use it for generation because it is not optimized for generation) -->
            valid_grid([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) :-
                emoji(X11, S11, C1) & emoji(X12, S12, C1) & emoji(X13, S13, C1) & emoji(X14, S14, C1) &
                mutex(S11, S12, S13, S14) &
                emoji(X21, S21, C2) & emoji(X22, S22, C2) & emoji(X23, S23, C2) & emoji(X24, S24, C2) &
                mutex(S21, S22, S23, S24) & mutex(C1, C2) &
                emoji(X31, S31, C3) & emoji(X32, S32, C3) & emoji(X33, S33, C3) & emoji(X34, S34, C3) &
                mutex(S31, S32, S33, S34) & mutex(C1, C2, C3) &
                emoji(X41, S41, C4) & emoji(X42, S42, C4) & emoji(X43, S43, C4) & emoji(X44, S44, C4) &
                mutex(S41, S42, S43, S44) & mutex(C1, C2, C3, C4)

            <!-- show potential solution -->
            click(solution_button_easy) ::  ~init_puzzle & ~solution ==> solution
            click(solution_button_easy) :: solution ==> ~solution
            click(solution_button_hard) ::  ~init_puzzle & ~solution ==> solution
            click(solution_button_hard) :: solution ==> ~solution
            style(puzzle_grid_ans, display, block) :- solution
            style(puzzle_grid_ans, display, none) :- ~solution

            <!-- For debug: pre-fill the answer in user grid -->
            <!-- fill_in([X11, X12, X13, X14, X21, X22, X23, X24, X31, X32, X33, X34, X41, X42, X43, X44]) ::
                value(cell(1,1), X11) & value(cell(1,2), X12) & value(cell(1,3), X13) & value(cell(1,4), X14) &
                value(cell(2,1), X21) & value(cell(2,2), X22) & value(cell(2,3), X23) & value(cell(2,4), X24) &
                value(cell(3,1), X31) & value(cell(3,2), X32) & value(cell(3,3), X33) & value(cell(3,4), X34) &
                value(cell(4,1), X41) & value(cell(4,2), X42) & value(cell(4,3), X43) & value(cell(4,4), X44) -->

        </ruleset>
        <!--=======================================================================-->

    </center>

<!-- The Modal -->
<div id="rulesModal" class="modal">
    <div class="modal-content">
        <span class="close" id="close_button" onclick="modbutton(this)">&times;</span>
        <h2>Here are the rules!</h2>
        <ul>
            <li>There are 4 shapes: circle ⚫, square ⬛, heart 🖤, book 📓</li>
            <li>There are 4 colors: red 🟥, blue 🟦, green 🟩, yellow 🟨</li>
            <li><strong><em>Goal:</em></strong> Fill the 4*4 grid with 16 emojis (4 shapes x 4 colors), and satisfy all the rules:</li>
                <ul>
                    <li><span class="rule-font">Rule 1: </span>Each row consists of 4 emojis with the same color</li>
                    <li><span class="rule-font">Rule 2: </span>Each row and each column consists of 4 emojis with distinct shapes </li>
                    <li><span class="rule-font">Rule 3: </span>Clues Section are the constraints that your solution should satisify</li>
                </ul>
            <li><strong><em>Mode:</em></strong>
                <ul>
                    <li><span class="mode-font">Easy Mode: </span>You win as long as all clues are satisified</li>
                    <li><span class="mode-font">Hard Mode: </span>You only win when your answer matches exactly as our answer</li>
                </ul>
            </li>
            <li>You can use <span class="addhint-font">Add Clue</span> button to add clues. Initially we will provide 7 clues and once you click <span class="addhint-font">Add Clue</span> button, one more clue will be provided. You can get at most <strong>12</strong> clues in total.</li>
            <!-- <li>Rule 4: You win the game if you fulfill Rule 1 & Rule 2 & all the clues</li> -->
        </ul>
    </div>
</div>
<script type="text/javascript" src="./js/epilog.js"></script>
<script type="text/javascript" src="./js/worksheets.js"></script>
<script src="./js/script.js"></script>
</body>

<grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open">
        <style>
            div.grammarly-desktop-integration {
                position: absolute;
                width: 1px;
                height: 1px;
                padding: 0;
                margin: -1px;
                overflow: hidden;
                clip: rect(0, 0, 0, 0);
                white-space: nowrap;
                border: 0;
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            div.grammarly-desktop-integration:before {
                content: attr(data-content);
            }
        </style>
        <div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration"
            data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}">
        </div>
    </template></grammarly-desktop-integration>

</html>